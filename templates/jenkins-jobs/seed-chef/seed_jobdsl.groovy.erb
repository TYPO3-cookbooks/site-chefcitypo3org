#!groovy
def organization = 'TYPO3-cookbooks'
def userType = 'orgs' // 'orgs' or 'users'
def repoFilter = ~/.*/

repoApi = new URL("https://api.github.com/${userType}/${organization}/repos?per_page=100")
repos = new groovy.json.JsonSlurper().parse(repoApi.newReader())

repos.findAll{ r -> r.name =~ repoFilter }.each {

  def repoName = it.name
  def jobName = "chef-cookbook-${repoName}".replaceAll('/','-')

  workflowJob(jobName) {
    displayName("Chef Cookbook: ${repoName}")

    properties {
        githubProjectUrl("https://github.com/${organization}/${repoName}")
    }

    triggers() {
      githubPush()
      // as of now, the ghprb plugin is not yet pipeline-compatible - see
      // https://github.com/jenkinsci/pipeline-plugin/blob/master/COMPATIBILITY.md
      // githubPullRequest {
      //   cron('H/5 * * * *')
      //   useGitHubHooks()
      //   permitAll()
      // }
    }

    definition {
      cps {
        sandbox()
        script('''
// do not modify this job manually - it is automatically set up by the Chef cookbook!

def place_kitchen_yaml() {
  if (fileExists('.kitchen.docker.yml')) {
    echo 'Using the cookbooks .kitchen.docker.yml'
  } else {
    echo 'Placing default .kitchen.docker.yml file in workspace'
    writeFile file: '.kitchen.docker.yml', text: \'\'\'driver:\n  name: docker\n  use_sudo: false\'\'\'
  }
}

// global variable holding the list of test-kitchen instances
def tk_instances = []

// allocate a node for the smaller steps
node {
  stage 'clone cookbook'
  git url: 'https://github.com/TYPO3-cookbooks/''' + repoName + '''.git', clean: true
  // we e.g. have a .kitchen.docker.yml left from the last run. Remove that using "clean: true"

  // see also http://atomic-penguin.github.io/blog/2014/04/29/stupid-jenkins-and-chef-tricks-part-1-rubocop/
  stage 'lint'
  sh 'foodcritic . -f all'
  sh 'rubocop --fail-level E'
  step([$class: 'WarningsPublisher', canComputeNew: false, canResolveRelativePaths: false, consoleParsers: [[parserName: 'Foodcritic'], [parserName: 'Rubocop']], defaultEncoding: '', excludePattern: '', healthy: '', includePattern: '', unHealthy: ''])
  step([$class: 'AnalysisPublisher'])

  stage 'berks'
  sh 'berks install'

  stage 'testkitchen prepare'
  env.KITCHEN_LOCAL_YAML=".kitchen.docker.yml"
  place_kitchen_yaml()
  // copy the workspace for our slaves
  stash includes: '**', name: 'cookbook'

  // read out the list of test instances from `kitchen list`
  sh 'KITCHEN_LOCAL_YAML=.kitchen.docker.yml kitchen list > KITCHEN_INSTANCES'
  def lines = readFile('KITCHEN_INSTANCES').split('\\n') // in the Chef template, we have to escape the backslash so that one remains!
  // skip the headline, read out all instances
  for (int i = 1; i < lines.size(); i++) {
    tk_instances << lines[i].tokenize(' ')[0]
  }

  // kitchen_list_output = "kitchen list".execute().text
  // this nice line is broken in Pipeline 2.0 https://issues.jenkins-ci.org/browse/JENKINS-26481
  // readFile('KITCHEN_INSTANCES').eachLine { line, count -> if (count > 0) tk_instances << line.tokenize(' ')[0] }

  echo "Found instances: " + tk_instances

}

// create the node objects that run our tests
test_nodes = [:]
for (int i = 0; i < tk_instances.size(); i++) {
  def instance_name = tk_instances.get(i)

  test_nodes["tk-${instance_name}"] = {
    node {
      // restore workspace
      unstash 'cookbook'

      // TODO: wrap this in try/catch, to make sure that we execute destroy
      withEnv(["KITCHEN_LOCAL_YAML=.kitchen.docker.yml"]) {
        wrap([$class: 'AnsiColorBuildWrapper', colorMapName: "XTerm"]) {
          sh 'kitchen test ' + instance_name
        }
      }
      // clean up the instance
      sh 'kitchen destroy ' + instance_name
    }
  }
}
// run all the previously prepared nodes/stages in parallel
stage name: 'testkitchen'
parallel test_nodes


node {
  stage 'upload'
  sh 'berks upload'
}

        ''')
      }
    }
  }

}


///////////////////////////////
// main chef-repo
///////////////////////////////

job('chef-repo') {

  displayName('Main Chef repo')

  scm {
    git("<%= node['site-chefcitypo3org']['main_repo'] %>", "steffen-test")
  }


  wrappers {
    colorizeOutput('xterm')
  }

  steps {
    // at first, we finalize the config so that we can still connect to the chef server (by symlinking ~/.chef/config.rb)
    shell('[ -h ".chef/knife.local.rb" ] && true || ln -s ~/.chef/config.rb .chef/knife.local.rb')


    shell('scripts/upload-changes.sh $GIT_PREVIOUS_COMMIT..$GIT_COMMIT')
  }
}
